<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-11-06T11:39:37+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Blog</title><subtitle>blog by Junha Hwang.
</subtitle><author><name>Junha Hwang</name></author><entry><title type="html">기초적인 DP</title><link href="http://localhost:4000/2025/11/05/BOJ27977.html" rel="alternate" type="text/html" title="기초적인 DP" /><published>2025-11-05T00:00:00+09:00</published><updated>2025-11-05T00:00:00+09:00</updated><id>http://localhost:4000/2025/11/05/BOJ27977</id><content type="html" xml:base="http://localhost:4000/2025/11/05/BOJ27977.html"><![CDATA[<p>DP 공부를 위한 간단한 DP 문제를 풀었다. (<a href="https://www.acmicpc.net/problem/27977" target="_blank">BOJ 27977</a>) 이다.</p>

<h4 id="문제-정의">문제 정의</h4>

<p>거리가 주어지고, 배터리 용량은 거리와 비례하며 충전소의 위치가 주어진다.<br />
충전소를 지나면 용량이 채워진다. 이 때, 배터리 용량의 최소를 구해야 한다.</p>

<h4 id="접근">접근</h4>

<!--more-->
<p>배터리 용량을 1부터 시작해서 끝까지 본다면 가능할 것이다. 그렇다면 시간복잡도는 O(lxn)이다.<br />
10만x20만 이므로 20초.. 정도 걸릴 것이다. 따라서 이분탐색을 통해 시간복잡도를 줄일 것이다.<br />
만약 어떤 입력 값에서 배터리 용량이 매우 크다면 당연히 이동이 가능할 것이다.<br />
이처럼 배터리 용량을 점점 감소시키면, 가능(T) → 불가능(F)으로 전환하는 구간이 존재한다.<br />
즉, 가능 여부는 단조성을 가지므로 최적화 문제를 결정 문제로 변환할 수 있다.</p>

<p>이제 이분 탐색을 체크할 함수를 만들어야 한다. 먼저 충전소의 거리가 mid보다 크다면 불가능이므로 false.<br />
그다음 거리의 합이 mid보다 크다면 카운트 추가 후 거리의 합을 초기화해야한다.<br />
그 카운트 수가 k값 이하라면 true, 아니라면 false를 반환한다.</p>

<h4 id="코드">코드</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 한 번 충전으로 mid까지 갈 때 k번 이하로 충전 체크</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 용량이 부족해 불가능</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">+</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 배터리 용량이 거리 합보다 작을 때</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">dist</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 누적 거리 카운트</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>  <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">l</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">((</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hi</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>다이나믹 프로그래밍 열심히</p>]]></content><author><name>Junha Hwang</name></author><category term="PS" /><summary type="html"><![CDATA[DP 공부를 위한 간단한 DP 문제를 풀었다. (BOJ 27977) 이다. 문제 정의 거리가 주어지고, 배터리 용량은 거리와 비례하며 충전소의 위치가 주어진다. 충전소를 지나면 용량이 채워진다. 이 때, 배터리 용량의 최소를 구해야 한다. 접근]]></summary></entry><entry><title type="html">250913</title><link href="http://localhost:4000/2025/09/13/%EC%9E%A1%EB%8B%B4.html" rel="alternate" type="text/html" title="250913" /><published>2025-09-13T00:00:00+09:00</published><updated>2025-09-13T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/13/%EC%9E%A1%EB%8B%B4</id><content type="html" xml:base="http://localhost:4000/2025/09/13/%EC%9E%A1%EB%8B%B4.html"><![CDATA[<p>스테이블 코인은 미래가 될까? 원화와 가치가 1:1로 고정된 디지털 화폐를 은행 예금처럼 넣어두기만 하면, 연10%의 수익이 발생하고, 돈이 필요할 땐 그와 연동된 카드를 꺼내 쓰면 되는 세상 말이다. Kast를 보면 멀지 않은 것 같긴 하다.
기술은 이미 존재하고, 남은 건 규제와 제도 뿐이고, 이 시스템을 한국에는 누가 먼저 처음 열 것인지..</p>

<!--more-->

<p>결국 굴지의 대기업이 블록체인이라는 것을 추상적으로 표현하고 드러내지 않으면서 상품을 출시하면 되지 않나 생각도 한다.</p>

<p>블록체인은 돈 이외에도 역할을 수행하고 있냐고 생각하냐면 답은 아니라고 할 것이다. 하지만 명심하자. 돈이라는 개념에는 무수히 많은 파생개념이 있다.
확실한 건 이건 망상이 아니라 가능한 미래라고 나는 본다.
누가 이 배의 조타수가 될 것인가? 적어도 나는 아니다.. 무서워 사람들의 돈을 만지는 거</p>]]></content><author><name>Junha Hwang</name></author><category term="일기" /><summary type="html"><![CDATA[스테이블 코인은 미래가 될까? 원화와 가치가 1:1로 고정된 디지털 화폐를 은행 예금처럼 넣어두기만 하면, 연10%의 수익이 발생하고, 돈이 필요할 땐 그와 연동된 카드를 꺼내 쓰면 되는 세상 말이다. Kast를 보면 멀지 않은 것 같긴 하다. 기술은 이미 존재하고, 남은 건 규제와 제도 뿐이고, 이 시스템을 한국에는 누가 먼저 처음 열 것인지..]]></summary></entry><entry><title type="html">Is Blockchain the Future of Secure Digital Identity Management?</title><link href="http://localhost:4000/2025/08/25/%EA%B8%B0%EC%82%AC%EC%9A%94%EC%95%BD1.html" rel="alternate" type="text/html" title="Is Blockchain the Future of Secure Digital Identity Management?" /><published>2025-08-25T00:00:00+09:00</published><updated>2025-08-25T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/25/%EA%B8%B0%EC%82%AC%EC%9A%94%EC%95%BD1</id><content type="html" xml:base="http://localhost:4000/2025/08/25/%EA%B8%B0%EC%82%AC%EC%9A%94%EC%95%BD1.html"><![CDATA[<p>이 글은 Tech Research Online에 실린 “<a href="https://techresearchonline.com/blog/blockchain-digital-identity-management/">Is Blockchain the Future of Secure Digital Identity Management?</a>” 기사를 바탕으로 작성됨</p>

<h3 id="기사-내용-요약">기사 내용 요약</h3>
<p>오늘날의 디지털 신원은 우리가 웹에 접근, 상호작용하는 기반이다. 하지만 최근 사이버 공격, 데이터 침해 사고의 급증으로 인하여 탈중앙화 시스템의 도입 가능성이 대두되고 있다. 이 기사에서는 기존의 신원 관리 시스템의 중앙 집중 DB 의존을 탈피하기 위한 블록체인 도입의 가능성을 말한다. 또한, 실제 진행되고 있는 블록체인 기반 신원 인증 프로젝트를 소개한다.</p>

<!--more-->

<h4 id="블록체인-도입의-이점">블록체인 도입의 이점</h4>

<p>블록체인 기술은 분산되고 투명한 구조를 바탕으로 디지털 신원 관리 방식에 대한 혁신을 불러온다. SSI(Self Sovereign Identity) 개념을 통해 개인은 자신의 신원 데이터에 대한 완전한 소유권과 통제권을 가질 수 있으며, 어떤 정보를 누구와 공유할지 직접 결정할 수 있다. 이는 불필요한 개인정보 노출을 막아 프라이버시를 강화하고, 사용자와 서비스 제공자 간의 신뢰를 높이는 데 기여한다. 또한 블록체인의 위변조가 어려운 특성과 효율적인 데이터 처리 구조는 신원 관리 과정의 안정성과 효율성을 동시에 확보할 수 있도록 지원한다. 따라서 블록체인은 기존의 패스워드 기반 시스템에 의존하지 않지 않는 신원 확인을 가능하게 한다.</p>

<h4 id="기술의-실제-적용">기술의 실제 적용</h4>

<p><strong>- Microsoft의 ION(Identity Overlay Network)</strong></p>

<p>블록체인에 기반한 마이크로소프트의 ION은 개인이 직접 제어하는 탈중앙화 신원을 제공하도록 한다.</p>

<p><strong>- 에스토니아의 e-Residency</strong></p>

<p>블록체인 기반 전자 신분증을 활용해 전 세계인이 원격으로 안전하게 비즈니스와 행정 서비스를 이용할 수 있도록 한다.</p>

<p><strong>- Sovrin</strong></p>

<p>로벌 공공 인프라를 목표로 설계된 SSI 네트워크로, 개인과 조직이 중앙 기관을 거치지 않고 신원을 증명하며 필요한 정보만 선택적으로 공유할 수 있는 환경을 제공한다.</p>

<h4 id="기술-도입의-효과">기술 도입의 효과</h4>

<p>지금이 블록체인 도입에 적기인 이유는 명확하다. 사이버 공격의 급증과 GDPR·CCPA 등 강화된 규제, 의료와 IoT 분야의 디지털 전환 가속화는 안전하고 상호운용 가능한 신원 관리 시스템의 필요성을 보여준다. 블록체인은 규제 준수와 개인정보 통제를 동시에 달성할 수 있는 기술로서, 이미 여러 분야에서 시범 적용되고 있다. 앞으로는 영지식증명(ZKP), 분산 식별자(DID), 검증 가능한 자격 증명(VC) 등 첨단 암호 기술과 함께, 바이오메트릭스 및 AI·ML의 통합을 통해 글로벌 신원 표준으로 발전할 가능성이 크다. 결국 블록체인은 보안, 투명성, 효율성을 갖춘 차세대 디지털 신원 관리의 핵심 기술로 자리 잡을 가능성이 높다.</p>

<h4 id="생각">생각</h4>

<p>추가 조사 결과, 대한민국에 도입된 모바일 신분증 또한 DID를 도입하고 있다. 분산 식별자(DID) 기술을 활용하여 사용자가 자신의 신원 정보를 직접 관리할 수 있도록 설계되어 있다. 이를 통해 개인정보 유출 위험을 줄이고, 다양한 온라인 및 오프라인 서비스에서 신원 확인을 간편하고 안전하게 수행할 수 있다. 또한, 정부와 민간 기관이 협력하여 신뢰할 수 있는 신원 인증 인프라를 구축 중에 있다. 개인적으로 추상적으로만 접하던 DID 기반 신원 기술이 수년간의 검증 후, 실제로 우리나라에 적용되고 있다는 사실이 인상 깊었다.</p>

<p>DID 기술은 개인에게 책임을 떠넘기는 것이 아닌가 생각도 해보았다. 결국 우리는 모든 정보를 완벽히 기억할 수 없기에 어딘가에 저장할 수밖에 없다. 로컬 저장이 이상적이지만, 평균적인 사용자는 생각보다 보안에 취약하다. 단순하게 생각해서, 잊어버렸는데 책임지라고 따질 수도 있는 법이다. 따라서 만약 신원 인증 서비스가 있다면, 탈중앙화 기반의 인증은 옵션이 되지 않을까 생각한다. 그것을 선택하기 전 충분한 주의를 주어야 하거나, 비탈릭 부테린이 말한 Guardian 같은 존재가 필요하다. 이는 사용자가 실수하거나 키를 분실했을 때 회복할 수 있는 안전망 역할을 할 수 있다. 사실 개인적으로 블록체인이 금융 그 이상의 영역을 완전히 대체할 수 있다고 보지는 않는다. 그러나 금융만으로도 이미 수많은 파생 구조와 응용이 가능하며, 그 자체로 충분한 가치를 만들어낼 수 있다고 생각한다. 그래도 과투자는 금물이다.</p>]]></content><author><name>Junha Hwang</name></author><category term="Journel" /><summary type="html"><![CDATA[이 글은 Tech Research Online에 실린 “Is Blockchain the Future of Secure Digital Identity Management?” 기사를 바탕으로 작성됨 기사 내용 요약 오늘날의 디지털 신원은 우리가 웹에 접근, 상호작용하는 기반이다. 하지만 최근 사이버 공격, 데이터 침해 사고의 급증으로 인하여 탈중앙화 시스템의 도입 가능성이 대두되고 있다. 이 기사에서는 기존의 신원 관리 시스템의 중앙 집중 DB 의존을 탈피하기 위한 블록체인 도입의 가능성을 말한다. 또한, 실제 진행되고 있는 블록체인 기반 신원 인증 프로젝트를 소개한다.]]></summary></entry><entry><title type="html">기초적인 BFS</title><link href="http://localhost:4000/2025/07/18/BOJ1926.html" rel="alternate" type="text/html" title="기초적인 BFS" /><published>2025-07-18T00:00:00+09:00</published><updated>2025-07-18T00:00:00+09:00</updated><id>http://localhost:4000/2025/07/18/BOJ1926</id><content type="html" xml:base="http://localhost:4000/2025/07/18/BOJ1926.html"><![CDATA[<p>BFS를 공부하기 위해 대표적이고 간단한 BFS(<a href="https://www.acmicpc.net/problem/1926" target="_blank">BOJ 1926</a>)를 풀았다.</p>

<h4 id="문제-정의">문제 정의</h4>

<p>도화지에 그림이 그려져 있을 때, 그림의 개수와 그 그림 중 가장 넓은 것의 넓이를 출력하는 문제이다.<br />
그림이란 1로 연결된 것을 의미하며, 가로나 세로로 연결된 1들은 하나의 그림으로 간주한다.<br />
그림의 넓이는 그림에 포함된 1의 개수이다.</p>

<h4 id="접근">접근</h4>

<!--more-->

<p>모든 칸을 (0, 0)부터 차례대로 확인한다.<br />
만약 현재 칸이 아직 방문하지 않은 그림이라면(또한 board가 1), 새로운 그림을 찾은 것이므로 그림의 개수를 1 카운트한다.<br />
그 지점에서부터 BFS를 시작하여 연결된 모든 그림 영역을 찾아 visit 표시를 하고 push 한다.<br />
BFS를 수행하며 area를 세어 현재 그림의 넓이를 계산한다.<br />
하나의 그림 탐색이 끝나면, 이 그림의 넓이가 이전에 찾은 가장 넓은 그림의 넓이보다 큰지 확인하고, 크다면 최댓값을 갱신한다.<br />
모든 칸을 확인할 때까지 위 과정을 반복한다.</p>

<h4 id="코드">코드</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define X first
#define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용
</span><span class="kt">int</span> <span class="n">board</span><span class="p">[</span><span class="mi">502</span><span class="p">][</span><span class="mi">502</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="mi">502</span><span class="p">][</span><span class="mi">502</span><span class="p">];</span> <span class="c1">// 해당 칸을 방문했는지 여부를 저장</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 상하좌우 네 방향을 의미</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
    
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>
			<span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">area</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

			<span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">});</span>
			<span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
		<span class="n">area</span><span class="o">++</span><span class="p">;</span>
    	<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 상하좌우 칸을 살펴볼 것이다.</span>
      			<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span>
      			<span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">Y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span> <span class="c1">// nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감</span>
      			
				<span class="k">if</span><span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 범위 밖일 경우 넘어감</span>
      			<span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">||</span> <span class="n">board</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 이미 방문한 칸이거나 파란 칸이 아닐 경우</span>
      			<span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// (nx, ny)를 방문했다고 명시</span>
      			<span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">});</span>
    			<span class="p">}</span>
  			<span class="p">}</span>
			<span class="n">mx</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span> <span class="o">&lt;&lt;</span> <span class="n">mx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>어려우</p>]]></content><author><name>Junha Hwang</name></author><category term="PS" /><summary type="html"><![CDATA[BFS를 공부하기 위해 대표적이고 간단한 BFS(BOJ 1926)를 풀았다. 문제 정의 도화지에 그림이 그려져 있을 때, 그림의 개수와 그 그림 중 가장 넓은 것의 넓이를 출력하는 문제이다. 그림이란 1로 연결된 것을 의미하며, 가로나 세로로 연결된 1들은 하나의 그림으로 간주한다. 그림의 넓이는 그림에 포함된 1의 개수이다. 접근]]></summary></entry><entry><title type="html">250717</title><link href="http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1.html" rel="alternate" type="text/html" title="250717" /><published>2025-07-17T00:00:00+09:00</published><updated>2025-07-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1</id><content type="html" xml:base="http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1.html"><![CDATA[<p>사실 이건 정말 간단하게 템플릿만 가져와서 몇 가지만 고치면 된다<br />
뭔가 개발이나 IT 관련된 전공이나 분야에 있다면 블로그는 가지고 있어야 한다는 그런 편견..이 있기도 하고<br />
이걸 계속 만지다 보면 마크다운 문법이나 html에 익숙해지지 않을까 생각을 하며<br />
내가 관심있는 주제에 대한 아카이빙은 좋은 거니까! 또 영어 연습장이 될 수도?</p>

<!--more-->

<h3 id="요즘의-생각">요즘의 생각</h3>
<p>잘하고 싶다. 잘하고 싶어 뭐든지 / 평균 이상은 할 수 있는게 나의 장점이라고 생각했는데
수학도 못하고 나는 까막눈이다. 관심이나 흥미를 가지는 것들을 깊게 파다보면 언젠가 되겠지</p>]]></content><author><name>Junha Hwang</name></author><category term="일기" /><summary type="html"><![CDATA[사실 이건 정말 간단하게 템플릿만 가져와서 몇 가지만 고치면 된다 뭔가 개발이나 IT 관련된 전공이나 분야에 있다면 블로그는 가지고 있어야 한다는 그런 편견..이 있기도 하고 이걸 계속 만지다 보면 마크다운 문법이나 html에 익숙해지지 않을까 생각을 하며 내가 관심있는 주제에 대한 아카이빙은 좋은 거니까! 또 영어 연습장이 될 수도?]]></summary></entry></feed>