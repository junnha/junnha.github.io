<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-07-18T00:07:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Blog</title><subtitle>blog by Junha Hwang.
</subtitle><author><name>Junha Hwang</name><email>junha320@gmail.com</email></author><entry><title type="html">Stack</title><link href="http://localhost:4000/2025/07/17/0x05.html" rel="alternate" type="text/html" title="Stack" /><published>2025-07-17T00:00:00+09:00</published><updated>2025-07-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/07/17/0x05</id><content type="html" xml:base="http://localhost:4000/2025/07/17/0x05.html"><![CDATA[<h3 id="스택의-성질">스택의 성질</h3>
<ul>
  <li>원소의 추가 O(1)</li>
  <li>원소의 제거 O(1)</li>
  <li>제일 상단의 원소 확인이 O(1)</li>
  <li>제일 상단이 아닌 원소의 확인/변경 불가능</li>
</ul>

<h2 id="기능과-구현">기능과 구현</h2>

<!--more-->

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">MX</span> <span class="o">=</span> <span class="mi">1000005</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dat</span><span class="p">[</span><span class="n">MX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">dat</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">pop</span><span class="p">(){</span>
    <span class="n">pos</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">top</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">dat</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="push">push</h4>
<ul>
  <li>스택의 맨 위에 요소를 추가</li>
  <li><code class="language-plaintext highlighter-rouge">s.push(10);</code></li>
</ul>

<h4 id="pop">pop</h4>
<ul>
  <li>스택의 맨 위 요소를 제거</li>
  <li><code class="language-plaintext highlighter-rouge">s.pop();</code></li>
</ul>

<h4 id="top">top</h4>
<ul>
  <li>스택의 맨 위 요소에 접근 (읽기/수정 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">int x = s.top();</code></li>
</ul>

<h4 id="empty">empty</h4>
<ul>
  <li>스택이 비어 있는지 확인</li>
  <li><code class="language-plaintext highlighter-rouge">if (s.empty()) { ... }</code></li>
</ul>

<h4 id="size">size</h4>
<ul>
  <li>스택에 들어 있는 요소 개수 반환</li>
  <li><code class="language-plaintext highlighter-rouge">int n = s.size();</code></li>
</ul>]]></content><author><name>Junha Hwang</name><email>junha320@gmail.com</email></author><category term="Learn" /><summary type="html"><![CDATA[스택의 성질 원소의 추가 O(1) 원소의 제거 O(1) 제일 상단의 원소 확인이 O(1) 제일 상단이 아닌 원소의 확인/변경 불가능 기능과 구현]]></summary></entry><entry><title type="html">기초적인 BFS</title><link href="http://localhost:4000/2025/07/17/ps.html" rel="alternate" type="text/html" title="기초적인 BFS" /><published>2025-07-17T00:00:00+09:00</published><updated>2025-07-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/07/17/ps</id><content type="html" xml:base="http://localhost:4000/2025/07/17/ps.html"><![CDATA[<p>BFS를 공부하기 위해 간단한 BFS를 풀어보았다.</p>

<h3 id="문제-정의">문제 정의</h3>

<p>도화지에 그림이 그려져 있을 때, 그림의 개수와 그 그림 중 가장 넓은 것의 넓이를 출력하는 문제입니다. 그림이란 1로 연결된 것을 의미하며, 가로나 세로로 연결된 1들은 하나의 그림으로 간주합니다. 그림의 넓이는 그림에 포함된 1의 개수입니다.</p>

<p>```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define X first
#define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용
int board[502][502];
bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1}; // 상하좌우 네 방향을 의미</p>

<p>int main(void){
  	ios::sync_with_stdio(0);
  	cin.tie(0);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int n,m;
cin &gt;&gt; n &gt;&gt; m;

for(int i=0;i&lt;n;i++) {
	for(int j=0;j&lt;m;j++) {
		cin &gt;&gt; board[i][j];
	}
}

int num = 0;
int mx = 0;

for(int i=0;i&lt;n;i++) {
	for(int j=0;j&lt;m;j++) {
		if(board[i][j] == 0 || vis[i][j] == 1) continue;
		num++;
		queue&lt;pair&lt;int,int&gt; &gt; Q;
		int area=0;

		Q.push({i,j});
		vis[i][j] = 1;

    while(!Q.empty()){
	area++;
	pair&lt;int,int&gt; cur = Q.front();
	Q.pop();
		for(int dir = 0; dir &lt; 4; dir++){ // 상하좌우 칸을 살펴볼 것이다.
  			int nx = cur.X + dx[dir];
  			int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감
  			
			if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; // 범위 밖일 경우 넘어감
  			if(vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우
  			vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시
  			Q.push({nx,ny});
			}
  			}
		mx = max(mx, area);
	}
}
cout &lt;&lt; num &lt;&lt; '\n' &lt;&lt; mx; }
</code></pre></div></div>]]></content><author><name>Junha Hwang</name><email>junha320@gmail.com</email></author><category term="PS" /><summary type="html"><![CDATA[BFS를 공부하기 위해 간단한 BFS를 풀어보았다. 문제 정의 도화지에 그림이 그려져 있을 때, 그림의 개수와 그 그림 중 가장 넓은 것의 넓이를 출력하는 문제입니다. 그림이란 1로 연결된 것을 의미하며, 가로나 세로로 연결된 1들은 하나의 그림으로 간주합니다. 그림의 넓이는 그림에 포함된 1의 개수입니다. ```cpp #include &lt;bits/stdc++.h&gt; using namespace std; #define X first #define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용 int board[502][502]; bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장 int dx[4] = {1,0,-1,0}; int dy[4] = {0,1,0,-1}; // 상하좌우 네 방향을 의미 int main(void){ ios::sync_with_stdio(0); cin.tie(0); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;m;j++) { cin &gt;&gt; board[i][j]; } } int num = 0; int mx = 0; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;m;j++) { if(board[i][j] == 0 || vis[i][j] == 1) continue; num++; queue&lt;pair&lt;int,int&gt; &gt; Q; int area=0; Q.push({i,j}); vis[i][j] = 1; while(!Q.empty()){ area++; pair&lt;int,int&gt; cur = Q.front(); Q.pop(); for(int dir = 0; dir &lt; 4; dir++){ // 상하좌우 칸을 살펴볼 것이다. int nx = cur.X + dx[dir]; int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감 if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; // 범위 밖일 경우 넘어감 if(vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우 vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시 Q.push({nx,ny}); } } mx = max(mx, area); } } cout &lt;&lt; num &lt;&lt; '\n' &lt;&lt; mx; }]]></summary></entry><entry><title type="html">250717</title><link href="http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1.html" rel="alternate" type="text/html" title="250717" /><published>2025-07-17T00:00:00+09:00</published><updated>2025-07-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1</id><content type="html" xml:base="http://localhost:4000/2025/07/17/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%83%9D%EC%84%B1.html"><![CDATA[<p>사실 이건 정말 간단하게 템플릿만 가져와서 몇 가지만 고치면 된다<br />
뭔가 개발이나 IT 관련된 전공이나 분야에 있다면 블로그는 가지고 있어야 한다는 그런 편견..이 있기도 하고<br />
이걸 계속 만지다 보면 마크다운 문법이나 html에 익숙해지지 않을까 생각을 하며<br />
내가 관심있는 주제에 대한 아카이빙은 좋은 거니까! 또 영어 연습장이 될 수도?</p>

<h3 id="요즘의-생각">요즘의 생각</h3>
<p>잘하고 싶다. 잘하고 싶어 뭐든지 / 평균 이상은 할 수 있는게 나의 장점이라고 생각했는데
수학도 못하고 나는 까막눈이다. 관심이나 흥미를 가지는 것들을 깊게 파다보면 언젠가 되겠지</p>]]></content><author><name>Junha Hwang</name><email>junha320@gmail.com</email></author><category term="일기" /><summary type="html"><![CDATA[사실 이건 정말 간단하게 템플릿만 가져와서 몇 가지만 고치면 된다 뭔가 개발이나 IT 관련된 전공이나 분야에 있다면 블로그는 가지고 있어야 한다는 그런 편견..이 있기도 하고 이걸 계속 만지다 보면 마크다운 문법이나 html에 익숙해지지 않을까 생각을 하며 내가 관심있는 주제에 대한 아카이빙은 좋은 거니까! 또 영어 연습장이 될 수도? 요즘의 생각 잘하고 싶다. 잘하고 싶어 뭐든지 / 평균 이상은 할 수 있는게 나의 장점이라고 생각했는데 수학도 못하고 나는 까막눈이다. 관심이나 흥미를 가지는 것들을 깊게 파다보면 언젠가 되겠지]]></summary></entry></feed>