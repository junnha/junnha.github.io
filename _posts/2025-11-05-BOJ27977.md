---
title: "기초적인 DP"
tags: PS
---

DP 공부를 위한 간단한 DP 문제를 풀었다. ([BOJ 27977](https://www.acmicpc.net/problem/27977){:target="_blank"}) 이다.

#### 문제 정의

거리가 주어지고, 배터리 용량은 거리와 비례하며 충전소의 위치가 주어진다.  
충전소를 지나면 용량이 채워진다. 이 때, 배터리 용량의 최소를 구해야 한다.

#### 접근

<!--more-->
먼저, 만약 어떤 입력 값에서 대부분의 경우 배터리 용량이 매우 클 때부터 생각한다면 당연히 가능할 것이다.  
이를 이용해 용량을 차근차근 감소 혹은 증가해나간다면 결국 TTTTFF거나 1부터 시작한다면 FFFFTT가 될 것이다.  
이렇게 생각하여 최대/최소를 구하는 최적화 문제를 결정 문제로 변환할 수 있다.  
이제 이분 탐색을 체크할 함수를 만들어야 한다. 먼저 충전소의 거리가 mid보다 크다면 불가능이므로 false.  
그다음 거리의 합이 mid보다 크다면 카운트 추가 후 거리의 합을 초기화해야한다.
그 카운트 수가 k값 이하라면 true.

#### 코드
```cpp
#include<bits/stdc++.h>
using namespace std;
int l, n, k;
vector<int> s;

bool check(int mid) {
    // 한 번 충전으로 mid까지 갈 때 k번 이하로 충전 체크
    int cnt = 0, dist = 0;

    for (int i = 1; i < s.size(); i++) {
        int d = s[i] - s[i - 1];
        if (d > mid) return false; // 용량이 부족해 불가능
        if (dist + d > mid) {
            // 배터리 용량이 거리 합보다 작을 때
            cnt++;
            dist = 0;
        }
        dist += d; // 누적 거리 카운트
    }
    return cnt <= k;
}


int main() {
    cin.tie(NULL);  ios_base::sync_with_stdio(false);
    cin >> l >> n >> k;
    s.push_back(0);
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        s.push_back(x);
    }
    s.push_back(l);
    int lo = 0;
    int hi = l;

    while (lo + 1 < hi) {
        int mid = ((lo + hi) / 2);
        if (check(mid)) hi = mid;
        else lo = mid;
    }
    cout << hi;
}
```
다이나믹 프로그래밍 열심히