---
title: "기초적인 DP"
tags: PS
key: BOJ27977
---

DP 공부를 위한 간단한 DP 문제를 풀었다. ([BOJ 27977](https://www.acmicpc.net/problem/27977){:target="_blank"}) 이다.

#### 문제 정의

거리가 주어지고, 배터리 용량은 거리와 비례하며 충전소의 위치가 주어진다.  
충전소를 지나면 용량이 채워진다. 이 때, 배터리 용량의 최소를 구해야 한다.

#### 접근

<!--more-->
배터리 용량을 1부터 시작해서 끝까지 본다면 가능할 것이다. 그렇다면 시간복잡도는 O(lxn)이다.  
10만x20만 이므로 20초.. 정도 걸릴 것이다. 따라서 이분탐색을 통해 시간복잡도를 줄일 것이다.  
만약 어떤 입력 값에서 배터리 용량이 매우 크다면 당연히 이동이 가능할 것이다.  
이처럼 배터리 용량을 점점 감소시키면, 가능(T) → 불가능(F)으로 전환하는 구간이 존재한다.  
즉, 가능 여부는 단조성을 가지므로 최적화 문제를 결정 문제로 변환할 수 있다.  

이제 이분 탐색을 체크할 함수를 만들어야 한다. 먼저 충전소의 거리가 mid보다 크다면 불가능이므로 false.  
그다음 거리의 합이 mid보다 크다면 카운트 추가 후 거리의 합을 초기화해야한다.  
그 카운트 수가 k값 이하라면 true, 아니라면 false를 반환한다.  

#### 코드
```cpp
#include<bits/stdc++.h>
using namespace std;
int l, n, k;
vector<int> s;

bool check(int mid) {
    // 한 번 충전으로 mid까지 갈 때 k번 이하로 충전 체크
    int cnt = 0, dist = 0;

    for (int i = 1; i < s.size(); i++) {
        int d = s[i] - s[i - 1];
        if (d > mid) return false; // 용량이 부족해 불가능
        if (dist + d > mid) {
            // 배터리 용량이 거리 합보다 작을 때
            cnt++;
            dist = 0;
        }
        dist += d; // 누적 거리 카운트
    }
    return cnt <= k;
}


int main() {
    cin.tie(NULL);  ios_base::sync_with_stdio(false);
    cin >> l >> n >> k;
    s.push_back(0);
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        s.push_back(x);
    }
    s.push_back(l);
    int lo = 0;
    int hi = l;

    while (lo + 1 < hi) {
        int mid = ((lo + hi) / 2);
        if (check(mid)) hi = mid;
        else lo = mid;
    }
    cout << hi;
}
```
다이나믹 프로그래밍 열심히